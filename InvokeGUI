Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.Application]::EnableVisualStyles()

# Define P/Invoke methods to hide console window
Add-Type @"
    using System;
    using System.Runtime.InteropServices;

    public class ConsoleHelper {
        [DllImport("kernel32.dll")]
        public static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll")]
        public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        public const int SW_HIDE = 0;
    }
"@

# Function to hide PowerShell console window
function Hide-Console {
    $consoleWindow = [ConsoleHelper]::GetConsoleWindow()
    if ($consoleWindow -ne [IntPtr]::Zero) {
        [ConsoleHelper]::ShowWindow($consoleWindow, [ConsoleHelper]::SW_HIDE) | Out-Null
    }
}

# Hide console window at script start
Hide-Console

# Create main form
$form = New-Object System.Windows.Forms.Form
$form.Text = "Remote Command Executor"
$form.Size = New-Object System.Drawing.Size(600,500)
$form.StartPosition = "CenterScreen"
$form.MinimumSize = New-Object System.Drawing.Size(400,400)

# Computer names controls
$lblComputers = New-Object System.Windows.Forms.Label
$lblComputers.Text = "Computer Names (separate by ; or new line):"
$lblComputers.Location = New-Object System.Drawing.Point(10,10)
$lblComputers.AutoSize = $true
$form.Controls.Add($lblComputers)

$btnClearComputers = New-Object System.Windows.Forms.Button
$btnClearComputers.Text = "Clear"
$btnClearComputers.Size = New-Object System.Drawing.Size(60,20)
$btnClearComputers.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 62),10)
$btnClearComputers.Anchor = 'Top,Right'
$btnClearComputers.Add_Click({ $txtComputers.Text = "" })
$form.Controls.Add($btnClearComputers)

$btnImportLastList = New-Object System.Windows.Forms.Button
$btnImportLastList.Text = "Import Last"
$btnImportLastList.Size = New-Object System.Drawing.Size(80,20)
$btnImportLastList.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 144),10)
$btnImportLastList.Anchor = 'Top,Right'
$btnImportLastList.Add_Click({
    try {
        $lastListPath = "$env:USERPROFILE\Desktop\RemoteICM\lastLIST.txt"
        if (Test-Path $lastListPath) {
            $txtComputers.Text = Get-Content -Path $lastListPath -Raw -ErrorAction Stop
        } else {
            [System.Windows.Forms.MessageBox]::Show("Last computer list not found.", "Info", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to import last computer list: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnImportLastList)

$btnImportAD = New-Object System.Windows.Forms.Button
$btnImportAD.Text = "Import AD"
$btnImportAD.Size = New-Object System.Drawing.Size(80,20)
$btnImportAD.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 226),10)
$btnImportAD.Anchor = 'Top,Right'
$btnImportAD.Add_Click({
    try {
        if (-not (Get-Module -ListAvailable -Name ActiveDirectory)) {
            throw "ActiveDirectory module not found. Please ensure it's installed."
        }
        Import-Module ActiveDirectory -ErrorAction Stop
        $computers = Get-ADComputer -Filter {Enabled -eq $true -and OperatingSystem -like "*Windows 11*"} -Properties Name | 
            Select-Object -ExpandProperty Name | Sort-Object
        if ($computers.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("No enabled Windows 11 computers found in AD.", "Info", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        } else {
            $txtComputers.Text = $computers -join "`r`n"
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to import AD computers: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnImportAD)

$txtComputers = New-Object System.Windows.Forms.TextBox
$txtComputers.Multiline = $true
$txtComputers.Location = New-Object System.Drawing.Point(10,30)
$txtComputers.Size = New-Object System.Drawing.Size(560,150)
$txtComputers.MinimumSize = New-Object System.Drawing.Size(200,50)
$txtComputers.Anchor = 'Top,Left,Right'
$txtComputers.ScrollBars = 'Vertical'
$form.Controls.Add($txtComputers)

# Commands controls
$lblCommands = New-Object System.Windows.Forms.Label
$lblCommands.Text = "Commands to Execute:"
$lblCommands.Location = New-Object System.Drawing.Point(10,190)
$lblCommands.AutoSize = $true
$form.Controls.Add($lblCommands)

$btnClearCommands = New-Object System.Windows.Forms.Button
$btnClearCommands.Text = "Clear"
$btnClearCommands.Size = New-Object System.Drawing.Size(60,20)
$btnClearCommands.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 62),190)
$btnClearCommands.Anchor = 'Top,Right'
$btnClearCommands.Add_Click({ $txtCommands.Text = "" })
$form.Controls.Add($btnClearCommands)

$btnLoadCommands = New-Object System.Windows.Forms.Button
$btnLoadCommands.Text = "Load from File"
$btnLoadCommands.Size = New-Object System.Drawing.Size(90,20)
$btnLoadCommands.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 154),190)
$btnLoadCommands.Anchor = 'Top,Right'
$btnLoadCommands.Add_Click({
    try {
        $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
        $openFileDialog.Filter = "Common types (*.txt;*.bat;*.ps1)|*.txt;*.bat;*.ps1|All files (*.*)|*.*"
        $openFileDialog.Title = "Select a command file"
        if ($openFileDialog.ShowDialog() -eq "OK") {
            $txtCommands.Text = Get-Content -Path $openFileDialog.FileName -Raw -ErrorAction Stop
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to load commands from file: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnLoadCommands)

$btnGetWorkstationInfo = New-Object System.Windows.Forms.Button
$btnGetWorkstationInfo.Text = "GetWorkstationInfo"
$btnGetWorkstationInfo.Size = New-Object System.Drawing.Size(110,20)
$btnGetWorkstationInfo.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 266),190)
$btnGetWorkstationInfo.Anchor = 'Top,Right'
$btnGetWorkstationInfo.Add_Click({
    try {
        $infoPath = "$env:USERPROFILE\Desktop\RemoteICM\GetWorkstationInfo.ps1"
        if (Test-Path $infoPath) {
            $txtCommands.Text = Get-Content -Path $infoPath -Raw -ErrorAction Stop
        } else {
            [System.Windows.Forms.MessageBox]::Show("GetWorkstationInfo.ps1 not found in $env:USERPROFILE\Desktop\RemoteICM.", "Info", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to import GetWorkstationInfo.ps1: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnGetWorkstationInfo)

$btnImportLastPS = New-Object System.Windows.Forms.Button
$btnImportLastPS.Text = "Import Last"
$btnImportLastPS.Size = New-Object System.Drawing.Size(80,20)
$btnImportLastPS.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 348),190)
$btnImportLastPS.Anchor = 'Top,Right'
$btnImportLastPS.Add_Click({
    try {
        $lastPSPath = "$env:USERPROFILE\Desktop\RemoteICM\lastPS.ps1"
        if (Test-Path $lastPSPath) {
            $txtCommands.Text = Get-Content -Path $lastPSPath -Raw -ErrorAction Stop
        } else {
            [System.Windows.Forms.MessageBox]::Show("Last command file not found.", "Info", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to import last commands: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnImportLastPS)

$txtCommands = New-Object System.Windows.Forms.TextBox
$txtCommands.Multiline = $true
$txtCommands.Location = New-Object System.Drawing.Point(10,210)
$txtCommands.Size = New-Object System.Drawing.Size(560,100)
$txtCommands.MinimumSize = New-Object System.Drawing.Size(200,50)
$txtCommands.Anchor = 'Top,Left,Right'
$txtCommands.ScrollBars = 'Vertical'
$form.Controls.Add($txtCommands)

# Throttle limit control
$lblThrottle = New-Object System.Windows.Forms.Label
$lblThrottle.Text = "Throttle Limit:"
$lblThrottle.Location = New-Object System.Drawing.Point(10,320)
$lblThrottle.AutoSize = $true
$lblThrottle.Anchor = 'Bottom,Left'
$form.Controls.Add($lblThrottle)

$numThrottle = New-Object System.Windows.Forms.NumericUpDown
$numThrottle.Minimum = 1
$numThrottle.Maximum = 100
$numThrottle.Value = 20
$numThrottle.Width = 50
$numThrottle.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 60),318)
$numThrottle.Anchor = 'Bottom,Right'
$form.Controls.Add($numThrottle)

# Progress bar
$progressBar = New-Object System.Windows.Forms.ProgressBar
$progressBar.Location = New-Object System.Drawing.Point(10,350)
$progressBar.Size = New-Object System.Drawing.Size(560,20)
$progressBar.Anchor = 'Bottom,Left,Right'
$form.Controls.Add($progressBar)

# Save to CSV checkbox
$chkSaveCsv = New-Object System.Windows.Forms.CheckBox
$chkSaveCsv.Text = "Save Results to CSV File"
$chkSaveCsv.Location = New-Object System.Drawing.Point(10,380)
$chkSaveCsv.Size = New-Object System.Drawing.Size(150,20)
$chkSaveCsv.Anchor = 'Bottom,Left'
$form.Controls.Add($chkSaveCsv)

# Run and Cancel buttons
$btnRun = New-Object System.Windows.Forms.Button
$btnRun.Text = "Execute"
$btnRun.Location = New-Object System.Drawing.Point(10,410)
$btnRun.Size = New-Object System.Drawing.Size(100,20)
$btnRun.Anchor = 'Bottom,Left'
$form.Controls.Add($btnRun)

$btnCancel = New-Object System.Windows.Forms.Button
$btnCancel.Text = "Cancel"
$btnCancel.Location = New-Object System.Drawing.Point(120,410)
$btnCancel.Size = New-Object System.Drawing.Size(100,20)
$btnCancel.Anchor = 'Bottom,Left'
$btnCancel.Enabled = $false
$form.Controls.Add($btnCancel)

# Status label
$lblStatus = New-Object System.Windows.Forms.Label
$lblStatus.Location = New-Object System.Drawing.Point(230,415)
$lblStatus.Size = New-Object System.Drawing.Size(400,20)
$lblStatus.Anchor = 'Bottom,Left'
$form.Controls.Add($lblStatus)

# Form resize event
$form.Add_Resize({
    $txtComputers.Width = $form.ClientSize.Width - 20
    $txtCommands.Width = $form.ClientSize.Width - 20
    $progressBar.Width = $form.ClientSize.Width - 20
    $lblStatus.Width = $form.ClientSize.Width - 240

    $btnClearComputers.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 62),10)
    $btnImportLastList.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 144),10)
    $btnImportAD.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 226),10)
    $btnClearCommands.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 62), ($txtComputers.Bottom + 10))
    $btnLoadCommands.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 154), ($txtComputers.Bottom + 10))
    $btnGetWorkstationInfo.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 266), ($txtComputers.Bottom + 10))
    $btnImportLastPS.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 348), ($txtComputers.Bottom + 10))
    $numThrottle.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 60), ($txtComputers.Bottom + 138))

    $bottomControlsHeight = 90
    $availableHeight = $form.ClientSize.Height - $bottomControlsHeight - 60
    
    if ($availableHeight -gt 150) {
        $txtComputers.Height = [Math]::Min($availableHeight * 0.6, 300)
        $lblCommands.Location = New-Object System.Drawing.Point(10, ($txtComputers.Bottom + 10))
        $txtCommands.Location = New-Object System.Drawing.Point(10, ($lblCommands.Bottom + 10))
        $txtCommands.Height = $availableHeight - $txtComputers.Height - 40
        
        $lblThrottle.Location = New-Object System.Drawing.Point(10, ($form.ClientSize.Height - 90))
        $numThrottle.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 60), ($form.ClientSize.Height - 92))
        $progressBar.Location = New-Object System.Drawing.Point(10, ($form.ClientSize.Height - 70))
        $chkSaveCsv.Location = New-Object System.Drawing.Point(10, ($form.ClientSize.Height - 50))
        $btnRun.Location = New-Object System.Drawing.Point(10, ($form.ClientSize.Height - 30))
        $btnCancel.Location = New-Object System.Drawing.Point(120, ($form.ClientSize.Height - 30))
        $lblStatus.Location = New-Object System.Drawing.Point(230, ($form.ClientSize.Height - 25))
    }
})

# Global variables
$script:LogPath = "$env:USERPROFILE\Desktop\RemoteICM\DebugLog.txt"
$script:CsvPath = $null
$script:IsCancelled = $false
$script:Job = $null

# Button click events
$btnRun.Add_Click({
    $script:IsCancelled = $false
    $lblStatus.Text = "Starting execution..."
    $btnRun.Enabled = $false
    $btnCancel.Enabled = $true
    $progressBar.Value = 0
    $form.Refresh()

    $computers = $txtComputers.Text -split '[;\r\n]' | Where-Object { $_ -ne "" }
    $commandText = $txtCommands.Text.Trim()
    
    Add-Content -Path $script:LogPath -Value "$(Get-Date): btnRun clicked, Computers: $($computers.Count), Command: $commandText, Throttle: $($numThrottle.Value)" -ErrorAction SilentlyContinue
    
    if ($computers.Count -eq 0 -or [string]::IsNullOrWhiteSpace($commandText)) {
        [System.Windows.Forms.MessageBox]::Show("Please enter computer names and commands.", "Input Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Input validation failed" -ErrorAction SilentlyContinue
        $btnRun.Enabled = $true
        $btnCancel.Enabled = $false
        $lblStatus.Text = ""
        return
    }

    $invalidComputers = $computers | Where-Object { $_ -match '[^\w\.-]' }
    if ($invalidComputers) {
        [System.Windows.Forms.MessageBox]::Show("Invalid computer names detected: $($invalidComputers -join ', ')", "Validation Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Invalid computer names: $($invalidComputers -join ', ')" -ErrorAction SilentlyContinue
        $btnRun.Enabled = $true
        $btnCancel.Enabled = $false
        $lblStatus.Text = ""
        return
    }

    # Save last computer list and commands
    try {
        $remoteICMDir = "$env:USERPROFILE\Desktop\RemoteICM"
        if (-not (Test-Path $remoteICMDir)) { New-Item -Path $remoteICMDir -ItemType Directory -Force | Out-Null }
        $txtComputers.Text | Out-File -FilePath "$remoteICMDir\lastLIST.txt" -Encoding UTF8 -ErrorAction Stop
        $txtCommands.Text | Out-File -FilePath "$remoteICMDir\lastPS.ps1" -Encoding UTF8 -ErrorAction Stop
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Saved last list and commands" -ErrorAction SilentlyContinue
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to save last list/commands: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Failed to save last list/commands: $_" -ErrorAction SilentlyContinue
    }

    # Initialize CSV file if saving is enabled
    if ($chkSaveCsv.Checked) {
        try {
            $remoteICMDir = "$env:USERPROFILE\Desktop\RemoteICM"
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $script:CsvPath = "$remoteICMDir\RemoteCommandResults_$timestamp.csv"
            [PSCustomObject]@{ ComputerName = ""; Status = ""; Timestamp = ""; Output = "" } | Export-Csv -Path $script:CsvPath -NoTypeInformation -ErrorAction Stop
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Initialized CSV at $script:CsvPath" -ErrorAction SilentlyContinue
        }
        catch {
            [System.Windows.Forms.MessageBox]::Show("Failed to initialize CSV: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Failed to initialize CSV: $_" -ErrorAction SilentlyContinue
            $btnRun.Enabled = $true
            $btnCancel.Enabled = $false
            $lblStatus.Text = ""
            return
        }
    }

    # Execute commands asynchronously
    $results = [System.Collections.ArrayList]::new()
    $scriptBlock = [ScriptBlock]::Create($commandText)
    $progressBar.Maximum = $computers.Count
    $processedCount = 0

    # Start job
    $script:Job = Invoke-Command -ComputerName $computers -ScriptBlock $scriptBlock -ThrottleLimit $numThrottle.Value -AsJob -SessionOption (New-PSSessionOption -OperationTimeout 30000)
    Add-Content -Path $script:LogPath -Value "$(Get-Date): Started job $($script:Job.Id)" -ErrorAction SilentlyContinue

    # Poll job status
    while ($script:Job.State -eq "Running" -and -not $script:IsCancelled) {
        $completedComputers = $script:Job.ChildJobs | Where-Object { $_.State -ne "Running" }
        $processedCount = $completedComputers.Count
        $progressBar.Value = $processedCount
        $lblStatus.Text = "Processing... ($processedCount of $($computers.Count))"
        $form.Refresh()
        Start-Sleep -Milliseconds 500  # Poll every 0.5 seconds
    }

    if ($script:IsCancelled) {
        $script:Job | Stop-Job -PassThru | Remove-Job -Force
        $lblStatus.Text = "Execution cancelled"
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Job cancelled" -ErrorAction SilentlyContinue
    } else {
        # Collect results
        $jobResults = $script:Job | Receive-Job -Wait -ErrorAction SilentlyContinue -ErrorVariable jobErrors
        $script:Job | Remove-Job
        foreach ($item in $jobResults) {
            $computer = $item.PSComputerName
            $result = [PSCustomObject]@{
                ComputerName = $computer
                Output       = if ($item) { $item | Out-String } else { "No output" }
                Status       = "Success"
                Timestamp    = Get-Date
            }
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Job for $computer succeeded, Output: $($result.Output)" -ErrorAction SilentlyContinue
            $null = $results.Add($result)
            if ($chkSaveCsv.Checked -and $script:CsvPath) {
                $result | Export-Csv -Path $script:CsvPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
            }
        }

        # Handle errors per computer
        foreach ($error in $jobErrors) {
            $computer = $error.TargetObject
            if ($computers -contains $computer -and -not ($results | Where-Object { $_.ComputerName -eq $computer })) {
                $result = [PSCustomObject]@{
                    ComputerName = $computer
                    Output       = $error.Exception.Message
                    Status       = if ($error.Exception -match "not online") { "Offline" } elseif ($error.Exception -match "timeout") { "Timeout" } else { "Error" }
                    Timestamp    = Get-Date
                }
                Add-Content -Path $script:LogPath -Value "$(Get-Date): Job for $computer failed: $($error.Exception.Message)" -ErrorAction SilentlyContinue
                $null = $results.Add($result)
                if ($chkSaveCsv.Checked -and $script:CsvPath) {
                    $result | Export-Csv -Path $script:CsvPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
                }
            }
        }

        # Ensure all computers are accounted for
        foreach ($computer in $computers) {
            if (-not ($results | Where-Object { $_.ComputerName -eq $computer })) {
                $result = [PSCustomObject]@{
                    ComputerName = $computer
                    Output       = "No response received"
                    Status       = "Error"
                    Timestamp    = Get-Date
                }
                Add-Content -Path $script:LogPath -Value "$(Get-Date): Job for $computer failed: No response received" -ErrorAction SilentlyContinue
                $null = $results.Add($result)
                if ($chkSaveCsv.Checked -and $script:CsvPath) {
                    $result | Export-Csv -Path $script:CsvPath -NoTypeInformation -Append -ErrorAction SilentlyContinue
                }
            }
        }

        $progressBar.Value = $computers.Count
        $lblStatus.Text = if ($chkSaveCsv.Checked -and $script:CsvPath) { "Completed - Results saved to: $script:CsvPath" } else { "Completed" }
    }

    # Display results
    if ($results.Count -gt 0) {
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Preparing to display $($results.Count) results in Out-GridView" -ErrorAction SilentlyContinue
        $results | Select-Object ComputerName, Status, Timestamp, Output | Out-GridView -Title "Remote Command Results"
    } else {
        Add-Content -Path $script:LogPath -Value "$(Get-Date): No results to display in Out-GridView" -ErrorAction SilentlyContinue
    }

    # Cleanup sessions
    Get-PSSession | Remove-PSSession -ErrorAction SilentlyContinue
    $btnRun.Enabled = $true
    $btnCancel.Enabled = $false
    Add-Content -Path $script:LogPath -Value "$(Get-Date): Execution finished, Results: $($results.Count)" -ErrorAction SilentlyContinue
})

$btnCancel.Add_Click({
    $script:IsCancelled = $true
    $lblStatus.Text = "Cancelling execution..."
    Add-Content -Path $script:LogPath -Value "$(Get-Date): Cancel requested" -ErrorAction SilentlyContinue
})

# Clean up on form close
$form.Add_FormClosing({
    $script:IsCancelled = $true
    if ($script:Job -and $script:Job.State -eq "Running") {
        $script:Job | Stop-Job -PassThru | Remove-Job -Force
    }
    Get-PSSession | Remove-PSSession -ErrorAction SilentlyContinue
    Add-Content -Path $script:LogPath -Value "$(Get-Date): Form closing" -ErrorAction SilentlyContinue
})

# Initialize log file
$remoteICMDir = "$env:USERPROFILE\Desktop\RemoteICM"
if (-not (Test-Path $remoteICMDir)) { New-Item -Path $remoteICMDir -ItemType Directory -Force | Out-Null }
if (Test-Path $script:LogPath) { Clear-Content -Path $script:LogPath }
Add-Content -Path $script:LogPath -Value "$(Get-Date): Script initialized" -ErrorAction SilentlyContinue

# Show the form
$form.ShowDialog()
