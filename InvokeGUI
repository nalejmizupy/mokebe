Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.Application]::EnableVisualStyles()

# Define P/Invoke methods to hide console window
Add-Type @"
    using System;
    using System.Runtime.InteropServices;

    public class ConsoleHelper {
        [DllImport("kernel32.dll")]
        public static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll")]
        public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        public const int SW_HIDE = 0;
    }
"@

# Function to hide PowerShell console window
function Hide-Console {
    $consoleWindow = [ConsoleHelper]::GetConsoleWindow()
    if ($consoleWindow -ne [IntPtr]::Zero) {
        [ConsoleHelper]::ShowWindow($consoleWindow, [ConsoleHelper]::SW_HIDE) | Out-Null
    }
}

# Hide console window at script start
Hide-Console

# Create main form
$form = New-Object System.Windows.Forms.Form
$form.Text = "Remote Command Executor"
$form.Size = New-Object System.Drawing.Size(600,500)
$form.StartPosition = "CenterScreen"
$form.MinimumSize = New-Object System.Drawing.Size(400,400)

# Computer names controls
$lblComputers = New-Object System.Windows.Forms.Label
$lblComputers.Text = "Computer Names (separate by ; or new line):"
$lblComputers.Location = New-Object System.Drawing.Point(10,10)
$lblComputers.AutoSize = $true
$form.Controls.Add($lblComputers)

$btnClearComputers = New-Object System.Windows.Forms.Button
$btnClearComputers.Text = "Clear"
$btnClearComputers.Size = New-Object System.Drawing.Size(60,20)
$btnClearComputers.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 62),10)
$btnClearComputers.Anchor = 'Top,Right'
$btnClearComputers.Add_Click({ $txtComputers.Text = "" })
$form.Controls.Add($btnClearComputers)

$btnImportLastList = New-Object System.Windows.Forms.Button
$btnImportLastList.Text = "Import Last"
$btnImportLastList.Size = New-Object System.Drawing.Size(80,20)
$btnImportLastList.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 144),10)
$btnImportLastList.Anchor = 'Top,Right'
$btnImportLastList.Add_Click({
    try {
        $lastListPath = "$env:USERPROFILE\Desktop\RemoteICM\lastLIST.txt"
        if (Test-Path $lastListPath) {
            $txtComputers.Text = Get-Content -Path $lastListPath -Raw -ErrorAction Stop
        } else {
            [System.Windows.Forms.MessageBox]::Show("Last computer list not found.", "Info", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to import last computer list: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnImportLastList)

$btnImportAD = New-Object System.Windows.Forms.Button
$btnImportAD.Text = "Import AD"
$btnImportAD.Size = New-Object System.Drawing.Size(80,20)
$btnImportAD.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 226),10)
$btnImportAD.Anchor = 'Top,Right'
$btnImportAD.Add_Click({
    try {
        if (-not (Get-Module -ListAvailable -Name ActiveDirectory)) {
            throw "ActiveDirectory module not found. Please ensure it's installed."
        }
        Import-Module ActiveDirectory -ErrorAction Stop
        $computers = Get-ADComputer -Filter {Enabled -eq $true -and OperatingSystem -like "*Windows 11*"} -Properties Name | 
            Select-Object -ExpandProperty Name | Sort-Object
        if ($computers.Count -eq 0) {
            [System.Windows.Forms.MessageBox]::Show("No enabled Windows 11 computers found in AD.", "Info", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        } else {
            $txtComputers.Text = $computers -join "`r`n"
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to import AD computers: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnImportAD)

$txtComputers = New-Object System.Windows.Forms.TextBox
$txtComputers.Multiline = $true
$txtComputers.Location = New-Object System.Drawing.Point(10,30)
$txtComputers.Size = New-Object System.Drawing.Size(560,150)
$txtComputers.MinimumSize = New-Object System.Drawing.Size(200,50)
$txtComputers.Anchor = 'Top,Left,Right'
$txtComputers.ScrollBars = 'Vertical'
$form.Controls.Add($txtComputers)

# Commands controls
$lblCommands = New-Object System.Windows.Forms.Label
$lblCommands.Text = "Commands to Execute:"
$lblCommands.Location = New-Object System.Drawing.Point(10,190)
$lblCommands.AutoSize = $true
$form.Controls.Add($lblCommands)

$btnClearCommands = New-Object System.Windows.Forms.Button
$btnClearCommands.Text = "Clear"
$btnClearCommands.Size = New-Object System.Drawing.Size(60,20)
$btnClearCommands.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 62),190)
$btnClearCommands.Anchor = 'Top,Right'
$btnClearCommands.Add_Click({ $txtCommands.Text = "" })
$form.Controls.Add($btnClearCommands)

$btnLoadCommands = New-Object System.Windows.Forms.Button
$btnLoadCommands.Text = "Load from File"
$btnLoadCommands.Size = New-Object System.Drawing.Size(90,20)
$btnLoadCommands.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 154),190)
$btnLoadCommands.Anchor = 'Top,Right'
$btnLoadCommands.Add_Click({
    try {
        $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
        $openFileDialog.Filter = "Common types (*.txt;*.bat;*.ps1)|*.txt;*.bat;*.ps1|All files (*.*)|*.*"
        $openFileDialog.Title = "Select a command file"
        if ($openFileDialog.ShowDialog() -eq "OK") {
            $txtCommands.Text = Get-Content -Path $openFileDialog.FileName -Raw -ErrorAction Stop
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to load commands from file: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnLoadCommands)

$btnGetWorkstationInfo = New-Object System.Windows.Forms.Button
$btnGetWorkstationInfo.Text = "GetWorkstationInfo"
$btnGetWorkstationInfo.Size = New-Object System.Drawing.Size(110,20)
$btnGetWorkstationInfo.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 266),190)
$btnGetWorkstationInfo.Anchor = 'Top,Right'
$btnGetWorkstationInfo.Add_Click({
    try {
        $infoPath = "$env:USERPROFILE\Desktop\RemoteICM\GetWorkstationInfo.ps1"
        if (Test-Path $infoPath) {
            $txtCommands.Text = Get-Content -Path $infoPath -Raw -ErrorAction Stop
        } else {
            [System.Windows.Forms.MessageBox]::Show("GetWorkstationInfo.ps1 not found in $env:USERPROFILE\Desktop\RemoteICM.", "Info", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to import GetWorkstationInfo.ps1: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnGetWorkstationInfo)

$btnImportLastPS = New-Object System.Windows.Forms.Button
$btnImportLastPS.Text = "Import Last"
$btnImportLastPS.Size = New-Object System.Drawing.Size(80,20)
$btnImportLastPS.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 348),190)
$btnImportLastPS.Anchor = 'Top,Right'
$btnImportLastPS.Add_Click({
    try {
        $lastPSPath = "$env:USERPROFILE\Desktop\RemoteICM\lastPS.ps1"
        if (Test-Path $lastPSPath) {
            $txtCommands.Text = Get-Content -Path $lastPSPath -Raw -ErrorAction Stop
        } else {
            [System.Windows.Forms.MessageBox]::Show("Last command file not found.", "Info", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Information)
        }
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to import last commands: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
    }
})
$form.Controls.Add($btnImportLastPS)

$txtCommands = New-Object System.Windows.Forms.TextBox
$txtCommands.Multiline = $true
$txtCommands.Location = New-Object System.Drawing.Point(10,210)
$txtCommands.Size = New-Object System.Drawing.Size(560,100)
$txtCommands.MinimumSize = New-Object System.Drawing.Size(200,50)
$txtCommands.Anchor = 'Top,Left,Right'
$txtCommands.ScrollBars = 'Vertical'
$form.Controls.Add($txtCommands)

# Concurrent runs control
$lblConcurrent = New-Object System.Windows.Forms.Label
$lblConcurrent.Text = "Max Concurrent Runs:"
$lblConcurrent.Location = New-Object System.Drawing.Point(10,320)
$lblConcurrent.AutoSize = $true
$lblConcurrent.Anchor = 'Bottom,Left'
$form.Controls.Add($lblConcurrent)

$numConcurrent = New-Object System.Windows.Forms.NumericUpDown
$numConcurrent.Minimum = 1
$numConcurrent.Maximum = 100
$numConcurrent.Value = 20
$numConcurrent.Width = 50
$numConcurrent.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 60),318)
$numConcurrent.Anchor = 'Bottom,Right'
$form.Controls.Add($numConcurrent)

# Progress bar
$progressBar = New-Object System.Windows.Forms.ProgressBar
$progressBar.Location = New-Object System.Drawing.Point(10,350)
$progressBar.Size = New-Object System.Drawing.Size(560,20)
$progressBar.Anchor = 'Bottom,Left,Right'
$form.Controls.Add($progressBar)

# Save to CSV checkbox
$chkSaveCsv = New-Object System.Windows.Forms.CheckBox
$chkSaveCsv.Text = "Save Results to CSV File"
$chkSaveCsv.Location = New-Object System.Drawing.Point(10,380)
$chkSaveCsv.Size = New-Object System.Drawing.Size(150,20)
$chkSaveCsv.Anchor = 'Bottom,Left'
$form.Controls.Add($chkSaveCsv)

# Run and Cancel buttons
$btnRun = New-Object System.Windows.Forms.Button
$btnRun.Text = "Execute"
$btnRun.Location = New-Object System.Drawing.Point(10,410)
$btnRun.Size = New-Object System.Drawing.Size(100,20)
$btnRun.Anchor = 'Bottom,Left'
$form.Controls.Add($btnRun)

$btnCancel = New-Object System.Windows.Forms.Button
$btnCancel.Text = "Cancel"
$btnCancel.Location = New-Object System.Drawing.Point(120,410)
$btnCancel.Size = New-Object System.Drawing.Size(100,20)
$btnCancel.Anchor = 'Bottom,Left'
$btnCancel.Enabled = $false
$form.Controls.Add($btnCancel)

# Status label
$lblStatus = New-Object System.Windows.Forms.Label
$lblStatus.Location = New-Object System.Drawing.Point(230,415)
$lblStatus.Size = New-Object System.Drawing.Size(400,20)
$lblStatus.Anchor = 'Bottom,Left'
$form.Controls.Add($lblStatus)

# Output form
$script:OutputForm = New-Object System.Windows.Forms.Form
$script:OutputForm.Text = "Command Output"
$script:OutputForm.Size = New-Object System.Drawing.Size(800,400)
$script:OutputForm.StartPosition = "CenterScreen"
$script:OutputForm.MinimumSize = New-Object System.Drawing.Size(600,300)
$script:OutputForm.FormBorderStyle = 'Sizable'
$script:OutputForm.AutoScroll = $true
$script:OutputForm.Add_FormClosing({ $_.Cancel = $true; $script:OutputForm.Hide() })
$script:OutputForm.Add_Shown({ $script:OutputForm.Refresh() })

$script:OutputGrid = New-Object System.Windows.Forms.DataGridView
$script:OutputGrid.Location = New-Object System.Drawing.Point(10,10)
$script:OutputGrid.Size = New-Object System.Drawing.Size(780,380)
$script:OutputGrid.Anchor = 'Top,Left,Bottom,Right'
$script:OutputGrid.ReadOnly = $true
$script:OutputGrid.AllowUserToAddRows = $false
$script:OutputGrid.ColumnHeadersHeightSizeMode = 'AutoSize'
$script:OutputGrid.AutoSizeColumnsMode = [System.Windows.Forms.DataGridViewAutoSizeColumnsMode]::AllCells
$script:OutputGrid.ScrollBars = [System.Windows.Forms.ScrollBars]::Both
$script:OutputGrid.Columns.Add("Computer", "Computer") | Out-Null
$script:OutputGrid.Columns.Add("Status", "Status") | Out-Null
$script:OutputGrid.Columns.Add("Timestamp", "Timestamp") | Out-Null
$script:OutputGrid.Columns.Add("Output", "Output") | Out-Null
$script:OutputForm.Controls.Add($script:OutputGrid)

# Form resize event
$form.Add_Resize({
    $txtComputers.Width = $form.ClientSize.Width - 20
    $txtCommands.Width = $form.ClientSize.Width - 20
    $progressBar.Width = $form.ClientSize.Width - 20
    $lblStatus.Width = $form.ClientSize.Width - 190

    $btnClearComputers.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 62),10)
    $btnImportLastList.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 144),10)
    $btnImportAD.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 226),10)
    $btnClearCommands.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 62), ($txtComputers.Bottom + 10))
    $btnLoadCommands.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 154), ($txtComputers.Bottom + 10))
    $btnGetWorkstationInfo.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 266), ($txtComputers.Bottom + 10))
    $btnImportLastPS.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 348), ($txtComputers.Bottom + 10))
    $numConcurrent.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 60), ($txtCommands.Bottom + 8))

    $bottomControlsHeight = 90
    $availableHeight = $form.ClientSize.Height - $bottomControlsHeight - 60
    
    if ($availableHeight -gt 150) {
        $txtComputers.Height = [Math]::Min($availableHeight * 0.6, 300)
        $lblCommands.Location = New-Object System.Drawing.Point(10, ($txtComputers.Bottom + 10))
        $txtCommands.Location = New-Object System.Drawing.Point(10, ($lblCommands.Bottom + 10))
        $txtCommands.Height = $availableHeight - $txtComputers.Height - 40
        
        $lblConcurrent.Location = New-Object System.Drawing.Point(10, ($form.ClientSize.Height - 90))
        $numConcurrent.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 60), ($form.ClientSize.Height - 92))
        $progressBar.Location = New-Object System.Drawing.Point(10, ($form.ClientSize.Height - 70))
        $chkSaveCsv.Location = New-Object System.Drawing.Point(10, ($form.ClientSize.Height - 50))
        $btnRun.Location = New-Object System.Drawing.Point(10, ($form.ClientSize.Height - 30))
        $btnCancel.Location = New-Object System.Drawing.Point(120, ($form.ClientSize.Height - 30))
        $lblStatus.Location = New-Object System.Drawing.Point(230, ($form.ClientSize.Height - 115))
    }
})

$script:OutputForm.Add_Resize({
    $script:OutputGrid.Width = $script:OutputForm.ClientSize.Width - 20
    $script:OutputGrid.Height = $script:OutputForm.ClientSize.Height - 20
    $script:OutputForm.Refresh()
})

# Global variables
$script:Jobs = New-Object 'System.Collections.Concurrent.ConcurrentBag[PSObject]'
$script:Results = [System.Collections.Concurrent.ConcurrentBag[PSObject]]::new()
$script:RunspacePool = $null
$script:IsCancelled = $false
$script:CompletedCount = 0
$script:TotalJobs = 0
$script:LogPath = "$env:USERPROFILE\Desktop\RemoteICM\DebugLog.txt"
$script:CsvPath = $null
$script:UpdateTimer = New-Object System.Windows.Forms.Timer
$script:LastGridUpdate = [DateTime]::MinValue  # Track last DataGridView update
$script:PendingResults = [System.Collections.ArrayList]::new()  # Buffer for results

# Timer setup for non-blocking execution
$script:UpdateTimer.Interval = 1000  # Check every 1 second
$script:UpdateTimer.Add_Tick({
    if ($script:Jobs.Count -gt 0 -and -not $script:IsCancelled) {
        $completedJobs = $script:Jobs | Where-Object { $_.Handle.IsCompleted }
        foreach ($job in $completedJobs) {
            $null = $script:Jobs.TryTake([ref]$job)
            try {
                $result = $job.PowerShell.EndInvoke($job.Handle)
                $script:CompletedCount++
                Add-Content -Path $script:LogPath -Value "$(Get-Date): Job for $($job.Computer) completed, Count: $script:CompletedCount" -ErrorAction SilentlyContinue
                
                if ($result) {
                    $script:Results.Add($result)
                    $script:PendingResults.Add($result) | Out-Null  # Buffer result
                    if ($chkSaveCsv.Checked -and $script:CsvPath) {
                        try {
                            $result | Export-Csv -Path $script:CsvPath -NoTypeInformation -Append -ErrorAction Stop
                            Add-Content -Path $script:LogPath -Value "$(Get-Date): Appended result for $($result.ComputerName) to CSV" -ErrorAction SilentlyContinue
                        }
                        catch {
                            Add-Content -Path $script:LogPath -Value "$(Get-Date): Failed to append to CSV: $_" -ErrorAction SilentlyContinue
                        }
                    }
                }
            }
            catch {
                $script:CompletedCount++
                $result = [PSCustomObject]@{
                    ComputerName = $job.Computer
                    Output       = $_.Exception.Message
                    Status       = "Error"
                    Timestamp    = Get-Date
                }
                $script:Results.Add($result)
                $script:PendingResults.Add($result) | Out-Null  # Buffer error result
                Add-Content -Path $script:LogPath -Value "$(Get-Date): Error ending job for $($job.Computer): $_" -ErrorAction SilentlyContinue
            }
            finally {
                $job.PowerShell.Dispose()
            }
        }

        # Update progress bar and status every tick
        $form.Invoke([Action]{
            $progressBar.Value = [Math]::Min($script:CompletedCount, $progressBar.Maximum)
            $lblStatus.Text = "Processing... ($script:CompletedCount of $($progressBar.Maximum))"
        })

        # Update DataGridView every 5 seconds
        $now = [DateTime]::Now
        if (($now - $script:LastGridUpdate).TotalSeconds -ge 5 -and $script:PendingResults.Count -gt 0) {
            $form.Invoke([Action]{
                foreach ($result in $script:PendingResults) {
                    $script:OutputGrid.Rows.Add($result.ComputerName, $result.Status, $result.Timestamp, $result.Output) | Out-Null
                }
                if ($script:OutputGrid.RowCount -gt 0) {
                    $script:OutputGrid.FirstDisplayedScrollingRowIndex = [Math]::Max(0, $script:OutputGrid.RowCount - 1)
                }
                $script:PendingResults.Clear()  # Clear buffer after update
            })
            $script:LastGridUpdate = $now
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Updated DataGridView with $($script:OutputGrid.RowCount) rows" -ErrorAction SilentlyContinue
        }
    }

    if ($script:CompletedCount -ge $script:TotalJobs -or $script:IsCancelled) {
        # Final DataGridView update before stopping
        if ($script:PendingResults.Count -gt 0) {
            $form.Invoke([Action]{
                foreach ($result in $script:PendingResults) {
                    $script:OutputGrid.Rows.Add($result.ComputerName, $result.Status, $result.Timestamp, $result.Output) | Out-Null
                }
                if ($script:OutputGrid.RowCount -gt 0) {
                    $script:OutputGrid.FirstDisplayedScrollingRowIndex = [Math]::Max(0, $script:OutputGrid.RowCount - 1)
                }
                $script:PendingResults.Clear()
            })
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Final DataGridView update with $($script:OutputGrid.RowCount) rows" -ErrorAction SilentlyContinue
        }

        $script:UpdateTimer.Stop()
        $form.Invoke([Action]{
            if ($script:IsCancelled) {
                $lblStatus.Text = "Execution cancelled"
            } else {
                $lblStatus.Text = if ($chkSaveCsv.Checked -and $script:CsvPath) { "Completed - Results saved to: $script:CsvPath" } else { "Completed" }
            }
            $btnRun.Enabled = $true
            $btnCancel.Enabled = $false
        })
        if ($script:RunspacePool -and $script:RunspacePool.RunspacePoolStateInfo.State -eq 'Opened') {
            $script:RunspacePool.Close()
            $script:RunspacePool.Dispose()
            $script:RunspacePool = $null
        }
        $script:IsCancelled = $false
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Execution finished, Results: $($script:Results.Count)" -ErrorAction SilentlyContinue
    }
})

# Reset function
function Reset-ScriptState {
    if ($script:UpdateTimer.Enabled) { $script:UpdateTimer.Stop() }
    if ($script:RunspacePool -and $script:RunspacePool.RunspacePoolStateInfo.State -eq 'Opened') {
        $script:RunspacePool.Close()
        $script:RunspacePool.Dispose()
        $script:RunspacePool = $null
    }
    $script:Jobs = New-Object 'System.Collections.Concurrent.ConcurrentBag[PSObject]'
    $script:Results = [System.Collections.Concurrent.ConcurrentBag[PSObject]]::new()
    $script:PendingResults = [System.Collections.ArrayList]::new()
    $script:IsCancelled = $false
    $script:CompletedCount = 0
    $script:TotalJobs = 0
    $script:CsvPath = $null
    $script:LastGridUpdate = [DateTime]::MinValue
    $progressBar.Value = 0
    $lblStatus.Text = ""
    $btnRun.Enabled = $true
    $btnCancel.Enabled = $false
    $script:OutputGrid.Rows.Clear()
    $script:OutputForm.Refresh()
    Add-Content -Path $script:LogPath -Value "$(Get-Date): Script state reset" -ErrorAction SilentlyContinue
}

# Button click events
$btnRun.Add_Click({
    Reset-ScriptState

    $computers = $txtComputers.Text -split '[;\r\n]' | Where-Object { $_ -ne "" }
    $commandText = $txtCommands.Text.Trim()
    
    Add-Content -Path $script:LogPath -Value "$(Get-Date): btnRun clicked, Computers: $($computers.Count), Command: $commandText" -ErrorAction SilentlyContinue
    
    if ($computers.Count -eq 0 -or [string]::IsNullOrWhiteSpace($commandText)) {
        [System.Windows.Forms.MessageBox]::Show("Please enter computer names and commands.", "Input Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Input validation failed" -ErrorAction SilentlyContinue
        return
    }

    $invalidComputers = $computers | Where-Object { $_ -match '[^\w\.-]' }
    if ($invalidComputers) {
        [System.Windows.Forms.MessageBox]::Show("Invalid computer names detected: $($invalidComputers -join ', ')", "Validation Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Invalid computer names: $($invalidComputers -join ', ')" -ErrorAction SilentlyContinue
        return
    }

    # Save last computer list and commands
    try {
        $remoteICMDir = "$env:USERPROFILE\Desktop\RemoteICM"
        if (-not (Test-Path $remoteICMDir)) { New-Item -Path $remoteICMDir -ItemType Directory -Force | Out-Null }
        $txtComputers.Text | Out-File -FilePath "$remoteICMDir\lastLIST.txt" -Encoding UTF8 -ErrorAction Stop
        $txtCommands.Text | Out-File -FilePath "$remoteICMDir\lastPS.ps1" -Encoding UTF8 -ErrorAction Stop
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Saved last list and commands" -ErrorAction SilentlyContinue
    }
    catch {
        [System.Windows.Forms.MessageBox]::Show("Failed to save last list/commands: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Failed to save last list/commands: $_" -ErrorAction SilentlyContinue
    }

    # Initialize CSV file if saving is enabled
    if ($chkSaveCsv.Checked) {
        try {
            $remoteICMDir = "$env:USERPROFILE\Desktop\RemoteICM"
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $script:CsvPath = "$remoteICMDir\RemoteCommandResults_$timestamp.csv"
            [PSCustomObject]@{ ComputerName = ""; Status = ""; Timestamp = ""; Output = "" } | Export-Csv -Path $script:CsvPath -NoTypeInformation -ErrorAction Stop
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Initialized CSV at $script:CsvPath" -ErrorAction SilentlyContinue
        }
        catch {
            [System.Windows.Forms.MessageBox]::Show("Failed to initialize CSV: $_", "Error", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Failed to initialize CSV: $_" -ErrorAction SilentlyContinue
            return
        }
    }

    $progressBar.Maximum = $computers.Count
    $script:TotalJobs = $computers.Count
    $btnRun.Enabled = $false
    $btnCancel.Enabled = $true
    $script:OutputForm.Show()
    $script:OutputForm.Refresh()
    $lblStatus.Text = "Starting execution..."

    # Initialize runspace pool
    if (-not $script:RunspacePool -or $script:RunspacePool.IsDisposed) {
        $script:RunspacePool = [RunspaceFactory]::CreateRunspacePool(1, $numConcurrent.Value)
        $script:RunspacePool.Open()
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Runspace pool opened with max concurrency $($numConcurrent.Value)" -ErrorAction SilentlyContinue
    }

    # Define the script block for runspaces
    $scriptBlock = {
        param($comp, $cmdText)
        $logPath = "$env:USERPROFILE\Desktop\RemoteICM\DebugLog.txt"
        Add-Content -Path $logPath -Value "$(Get-Date): Starting job for $comp" -ErrorAction SilentlyContinue
        try {
            $scriptBlock = [ScriptBlock]::Create($cmdText)
            $output = Invoke-Command -ComputerName $comp -ScriptBlock $scriptBlock -ErrorAction Stop -SessionOption (New-PSSessionOption -OperationTimeout 30000)
            $result = [PSCustomObject]@{
                ComputerName = $comp
                Output       = if ($output) { $output | Out-String } else { "No output" }
                Status       = "Success"
                Timestamp    = Get-Date
            }
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Job for $comp succeeded, Output: $($result.Output)" -ErrorAction SilentlyContinue
            return $result
        }
        catch {
            $result = [PSCustomObject]@{
                ComputerName = $comp
                Output       = $_.Exception.Message
                Status       = if ($_.Exception -match "not online") { "Offline" } elseif ($_.Exception -match "timeout") { "Timeout" } else { "Error" }
                Timestamp    = Get-Date
            }
            Add-Content -Path $script:LogPath -Value "$(Get-Date): Job for $comp failed: $($_.Exception.Message)" -ErrorAction SilentlyContinue
            return $result
        }
    }

    # Start all jobs asynchronously
    foreach ($computer in $computers) {
        $computer = $computer.Trim()
        Add-Content -Path $script:LogPath -Value "$(Get-Date): Queuing job for $computer" -ErrorAction SilentlyContinue
        
        $powershell = [PowerShell]::Create()
        $powershell.RunspacePool = $script:RunspacePool
        $powershell.AddScript($scriptBlock).AddParameter("comp", $computer).AddParameter("cmdText", $commandText) | Out-Null
        $handle = $powershell.BeginInvoke()
        $job = [PSCustomObject]@{
            PowerShell = $powershell
            Handle     = $handle
            Computer   = $computer
        }
        $script:Jobs.Add($job)
    }

    # Start the timer to check job completion
    $script:LastGridUpdate = [DateTime]::Now  # Initialize last update time
    $script:UpdateTimer.Start()
    Add-Content -Path $script:LogPath -Value "$(Get-Date): Started timer with $($computers.Count) jobs" -ErrorAction SilentlyContinue
})

$btnCancel.Add_Click({
    $script:IsCancelled = $true
    $lblStatus.Text = "Cancelling execution..."
    Add-Content -Path $script:LogPath -Value "$(Get-Date): Cancel requested" -ErrorAction SilentlyContinue
})

# Clean up on form close
$form.Add_FormClosing({
    $script:IsCancelled = $true
    if ($script:UpdateTimer.Enabled) { $script:UpdateTimer.Stop() }
    if ($script:RunspacePool -and $script:RunspacePool.RunspacePoolStateInfo.State -eq 'Opened') {
        $script:RunspacePool.Close()
        $script:RunspacePool.Dispose()
    }
    $script:OutputForm.Close()
    Add-Content -Path $script:LogPath -Value "$(Get-Date): Form closing" -ErrorAction SilentlyContinue
})

# Initialize log file
$remoteICMDir = "$env:USERPROFILE\Desktop\RemoteICM"
if (-not (Test-Path $remoteICMDir)) { New-Item -Path $remoteICMDir -ItemType Directory -Force | Out-Null }
if (Test-Path $script:LogPath) { Clear-Content -Path $script:LogPath }
Add-Content -Path $script:LogPath -Value "$(Get-Date): Script initialized" -ErrorAction SilentlyContinue

# Show the form
$form.ShowDialog()
